%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arsclassica Article
% LaTeX Template
% Version 1.1 (1/8/17)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Lorenzo Pantieri (http://www.lorenzopantieri.net) with extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[
10pt, % Main document font size
a4paper, % Paper type, use 'letterpaper' for US Letter paper
oneside, % One page layout (no page indentation)
%twoside, % Two page layout (page indentation for binding and different headers)
headinclude,footinclude, % Extra spacing for the header and footer
BCOR5mm, % Binding correction
]{scrartcl}

\input{structure.tex} % Include the structure.tex file which specified the document structure and layout

\hyphenation{Fortran hy-phen-ation} % Specify custom hyphenation points in words with dashes where you would like hyphenation to occur, or alternatively, don't put any dashes in a word to stop hyphenation altogether

\usepackage{color}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\usepackage{listings}
\lstset{language=Java,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\ttfamily%,
%  moredelim=[il][\textcolor{pgrey}]{$$},
%  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}

\usepackage{caption}

\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{%
  \parbox{\textwidth}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}\vskip-4pt}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{frame=lrb,xleftmargin=\fboxsep,xrightmargin=-\fboxsep}

%----------------------------------------------------------------------------------------
%	TITLE AND AUTHOR(S)
%----------------------------------------------------------------------------------------

\title{\normalfont\spacedallcaps{Character Device}} % The article title

\subtitle{Op de Raspberry PI type 1A} % Uncomment to display a subtitle

\author{\spacedlowsmallcaps{Suzanne Peerdeman \& Tim Visser}} % The article author(s) - author affiliations need to be specified in the AUTHOR AFFILIATIONS block

\date{} % An optional date to appear under the author(s)

%----------------------------------------------------------------------------------------

\begin{document}

%----------------------------------------------------------------------------------------
%	HEADERS
%----------------------------------------------------------------------------------------

\renewcommand{\sectionmark}[1]{\markright{\spacedlowsmallcaps{#1}}} % The header for all pages (oneside) or for even pages (twoside)
%\renewcommand{\subsectionmark}[1]{\markright{\thesubsection~#1}} % Uncomment when using the twoside option - this modifies the header on odd pages
\lehead{\mbox{\llap{\small\thepage\kern1em\color{halfgray} \vline}\color{halfgray}\hspace{0.5em}\rightmark\hfil}} % The header style

\pagestyle{scrheadings} % Enable the headers specified in this block

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS & LISTS OF FIGURES AND TABLES
%----------------------------------------------------------------------------------------

\maketitle % Print the title/author/date block

\setcounter{tocdepth}{2} % Set the depth of the table of contents to show sections and subsections only

%\tableofcontents % Print the table of contents

%\listoffigures % Print the list of figures

%\listoftables % Print the list of tables

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

%\section*{Abstract} % This section will not appear in the table of contents due to the star (\section*)
%
%This research gives an answer to the question if outputs generated by \texttt{java.util.Random.nextFloat()} follow a clear pattern. It uses Java code in combination with the Renjin library (R language) to first recursively generate outputs and secondly analyze these outputs. The research then looks at these analyses and tries to find correlations within. A clear pattern in the outputs of \texttt{java.util.Random.nextFloat()} is found.
%
%\newpage % Start the article content on the second page, remove this if you have a longer abstract that goes onto the second page

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\section{Introduction}

For this assignment we decided to create a loadable kernel module. A loadable kernel module means that the module in question can be compiled without recompiling the entire kernel, so rather than changing the existing kernel the module will extend the kernel. This will save both time when compiling, and effort when coding. This paper will decribe the kernel module that we have created: It will deliver a message at boot and shutdown, and it will control one of the GPIO (general purpose input/output) pins on the raspberry pi in order to blink a LED. The code will be written in the programming language C.
 
%----------------------------------------------------------------------------------------
%	PREPARATIONS
%----------------------------------------------------------------------------------------

\section{Preparations}

Before getting started on writing the code for the driver, a few preparations are in order. Because the driver will be cross compiled on a windows machine, the following prerequisites are required:

\begin{itemize}
	\item A virtualbox image with a Linux-OS. For this paper Ubuntu 16.04 was used
	\item Clion IDE
	\item RPi toolchain for cross-compilation (https://github.com/
raspberrypi/tools)
\end{itemize}

When developing software on a different platform than where the software will eventually be running, one is faced with several options. One could for example write the code on one platform, then transfer it to the target platform for compiling. This approach ensures that the software will run properly in the target environment. The downside, however, is that this method takes needless amounts of work and is often times (depending on the target environment) very slow.

This is why the RPi toolchain is very useful. The toolchain contains everything that is needed to develop software for the RPi externally, so that one can rely on the far superior CPU of a pc, rather than that of the RPi, when compiling. Information on how to set up the toolchain for Clion can be found here:
 https://stackoverflow.com/questions/19162072/installing-raspberry-pi-cross-compiler
  
%----------------------------------------------------------------------------------------
%	KERNEL MODULE
%----------------------------------------------------------------------------------------

\section{Kernel Module}

As mentioned earlier, we will avoid having to compile the entire kernel by writing a kernel module instead. The result will be similar to writing a custom kernel, but instead allows us to only code the part that we want, and adding this to the existing kernel.

%----------------------------------------------------------------------------------------
%	APPROACH
%----------------------------------------------------------------------------------------

\section{Approach}

First and foremost we must make sure that the OS is up to date.


\begin{lstlisting}

#Standard Linux-OS update routine
apt-get update -y
apt-get upgrade -y

#Update kernel
rpi-update

\end{lstlisting}

Once this is done the system will need to reboot. When the system has finished rebooting we can begin writing our driver. The first step to this is to download the RPi source code. The Wget tool will help with this.

\begin{lstlisting}

sudo wget https://raw.githubusercontent.com/notro/rpi-source/master/rpi-
source -O /usr/bin/rpi-source

\end{lstlisting}

Now to make sure we can execute:

\begin{lstlisting}

sudo chmod +x /usr/bin/rpi-source

\end{lstlisting}

Now to indicate that this is the final version of the script, and it will not be changed:

\begin{lstlisting}

/usr/bin/rpi-source -q --tag-update

\end{lstlisting}

Then the code is ready to run.

\begin{lstlisting}

rpi-source

\end{lstlisting}

And we are ready to start working on our driver.

%----------------------------------------------------------------------------------------
%	CODING THE DRIVER
%----------------------------------------------------------------------------------------

\section{Coding the Driver}

Now that the RPi is prepped and ready for our software, it is time to begin coding said software. We will begin by creating a folder, in our case naming it KernelModuleRPI. In this folder we create several files. To compile everything we will need a Makefile.

\begin{lstlisting}

obj -m := suzanne_tim.o

\end{lstlisting}

Next is a header file which helps with calling our driver.

\begin{lstlisting}

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

void LED_aan(void) {
  signed int fd, ret;
  fd = open("/dev/suzanne_tim_driver", O_RDWR);
  if (fd < 0) {
    perror("Failed to open character device...");
  }
  ret = write(fd, "1", 1);
  if (ret < 0) {
    perror("Failed to write 1 to the character device...");
  }
}

void LED_uit(void) {
  signed int fd, ret;
  fd = open("/dev/suzanne_tim_driver", O_RDWR);
  if (fd < 0) {
    perror("Failed to open character device...");
  }
  ret = write(fd, "0", 1);
  if (ret < 0) {
    perror("Failed to write 0 to the character device...");
  }
}
\end{lstlisting}

The driver:

\begin{lstlisting}

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <asm/uaccess.h>
#include <linux/gpio.h>
#include <asm/gpio.h>


#define DEVICE_NAME "suzanne_tim_driver"
#define DEVICE_MAJOR  69
#define GPIO_LED_PIN 21


MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("Character Device");
MODULE_AUTHOR("Suzanne Peerdeman & Tim Visser");

static unsigned long procfs_buffer_size = 0;
static char buffer_data[3];
static char led_status = 0;

static int device_open(struct inode *inode, struct file *file);
static int device_release(struct inode *inode, struct file *file);
static ssize_t device_write(struct file *file, const char *buffer, size_t len, loff_t *offset);

static struct file_operations fops = 
{
  .owner    = THIS_MODULE,
  .open     = device_open,
  .release  = device_release,
  .write    = device_write,
};


int suzanne_tim_init(void) {
	pr_alert("Character Device van Suzanne Peerdeman & Tim Visser\n");
	int ret;
	ret = register_chrdev(DEVICE_MAJOR, DEVICE_NAME, &fops);

	return 0;
}

void suzanne_tim_exit(void) {
	gpio_free(GPIO_LED_PIN);
	unregister_chrdev(DEVICE_MAJOR, DEVICE_NAME);
	pr_alert("Character Device ontkoppeld...\n");
}

static ssize_t device_write(struct file *file, const char *buffer, size_t len, loff_t *offset) {
	procfs_buffer_size = len;
	if (copy_from_user(buffer_data, buffer, procfs_buffer_size)) {
	  return -EFAULT;
	}
	*offset += len;
	if (buffer_data[0] == '1') {
	  led_status = 1;
	  gpio_set_value(GPIO_LED_PIN, led_status);
	  printk(KERN_ALERT "GPIO %d is set HIGH\n", GPIO_LED_PIN);
	} else if (buffer_data[0] == '0') {
	  led_status = 0;
	  gpio_set_value(GPIO_LED_PIN, led_status);
	  printk(KERN_ALERT "GPIO %d is set LOW\n", GPIO_LED_PIN);
	}
	pr_info("Received data...");
	pr_info("Data received: %s\n", buffer_data);
	return procfs_buffer_size;
}

static int device_open(struct inode *inode, struct file *file) {
	gpio_set_value(GPIO_LED_PIN, led_status);
	printk(KERN_ALERT "GPIO %d is set HIGH\n", GPIO_LED_PIN);
	return 0;
}

static int device_release(struct inode *inode, struct file *file) {
	gpio_set_value(GPIO_LED_PIN, led_status);
	printk(KERN_ALERT "GPIO %d is set LOW\n", GPIO_LED_PIN);
	return 0;
}

module_init(suzanne_tim_init);
module_exit(suzanne_tim_exit);

\end{lstlisting}

And finally to test the driver:

\begin{lstlisting}

#include "suzanne_tim.h"
#include <unistd.h>

int main (int argc, char **argv) {

    while (1) {
        LED_aan();
        usleep(1000000);
        LED_uit();
        usleep(1000000);
    }

    return 0;
}

\end{lstlisting}

When all this is done the driver needs to be compiled as 'kernel module'.

\begin{lstlisting}

make -C /lib/modules/$(uname -r)/build M=$(pwd) modules

\end{lstlisting}

This yields a .ko file. This is a 'kernel object', which can be loaded into the kernel by the command line actions:

\begin{lstlisting}

sudo insmod suzanne_tim.ko
sudo mknod /dev/suzanne_tim_driver c 69 0

\end{lstlisting}

And we are done!

\end{document}
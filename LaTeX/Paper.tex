%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arsclassica Article
% LaTeX Template
% Version 1.1 (1/8/17)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Lorenzo Pantieri (http://www.lorenzopantieri.net) with extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[
10pt, % Main document font size
a4paper, % Paper type, use 'letterpaper' for US Letter paper
oneside, % One page layout (no page indentation)
%twoside, % Two page layout (page indentation for binding and different headers)
headinclude,footinclude, % Extra spacing for the header and footer
BCOR5mm, % Binding correction
]{scrartcl}

\input{structure.tex} % Include the structure.tex file which specified the document structure and layout

\hyphenation{Fortran hy-phen-ation} % Specify custom hyphenation points in words with dashes where you would like hyphenation to occur, or alternatively, don't put any dashes in a word to stop hyphenation altogether

\usepackage{color}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\usepackage{listings}
\lstset{language=Java,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\ttfamily%,
%  moredelim=[il][\textcolor{pgrey}]{$$},
%  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}

\usepackage{caption}

\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{%
  \parbox{\textwidth}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}\vskip-4pt}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{frame=lrb,xleftmargin=\fboxsep,xrightmargin=-\fboxsep}

%----------------------------------------------------------------------------------------
%	TITLE AND AUTHOR(S)
%----------------------------------------------------------------------------------------

\title{\normalfont\spacedallcaps{Character Device}} % The article title

\subtitle{Op de Raspberry PI type 1A} % Uncomment to display a subtitle

\author{\spacedlowsmallcaps{Suzanne Peerdeman \& Tim Visser}} % The article author(s) - author affiliations need to be specified in the AUTHOR AFFILIATIONS block

\date{} % An optional date to appear under the author(s)

%----------------------------------------------------------------------------------------

\begin{document}

%----------------------------------------------------------------------------------------
%	HEADERS
%----------------------------------------------------------------------------------------

\renewcommand{\sectionmark}[1]{\markright{\spacedlowsmallcaps{#1}}} % The header for all pages (oneside) or for even pages (twoside)
%\renewcommand{\subsectionmark}[1]{\markright{\thesubsection~#1}} % Uncomment when using the twoside option - this modifies the header on odd pages
\lehead{\mbox{\llap{\small\thepage\kern1em\color{halfgray} \vline}\color{halfgray}\hspace{0.5em}\rightmark\hfil}} % The header style

\pagestyle{scrheadings} % Enable the headers specified in this block

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS & LISTS OF FIGURES AND TABLES
%----------------------------------------------------------------------------------------

\maketitle % Print the title/author/date block

\setcounter{tocdepth}{2} % Set the depth of the table of contents to show sections and subsections only

%\tableofcontents % Print the table of contents

%\listoffigures % Print the list of figures

%\listoftables % Print the list of tables

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

%\section*{Abstract} % This section will not appear in the table of contents due to the star (\section*)
%
%This research gives an answer to the question if outputs generated by \texttt{java.util.Random.nextFloat()} follow a clear pattern. It uses Java code in combination with the Renjin library (R language) to first recursively generate outputs and secondly analyze these outputs. The research then looks at these analyses and tries to find correlations within. A clear pattern in the outputs of \texttt{java.util.Random.nextFloat()} is found.
%
%\newpage % Start the article content on the second page, remove this if you have a longer abstract that goes onto the second page

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\section{Introduction}

For this assignment we decided to create a loadable kernel module. A loadable kernel module means that the module in question can be compiled without recompiling the entire kernel, so rather than changing the existing kernel the module will extend the kernel. This will save both time when compiling, and effort when coding. This paper will highlight two kernel modules that we have created: the first will deliver a message at boot and shutdown, and the second will control one of the GPIO (general purpose input/output) pins on the raspberry pi in order to blink a LED. The code will be written in the programming language C.
 
%----------------------------------------------------------------------------------------
%	EXPERIMENTAL SETUP
%----------------------------------------------------------------------------------------

\section{Experimental Setup}

CODE UITLEGGEN EN WEGHALEN ALS CODE
This research uses Java code and R code that is interpreted in the JVM through the \href{http://www.renjin.org/}{Renjin} library. The JVM has been given the arguments \texttt{-Xms2048M} and \texttt{-Xmx2048m} to increase the stack size to the maximum for a 64-bit JVM.
\\
\\
To retrieve outputs from \texttt{java.util.Random} the following code will be used:
\begin{lstlisting}[label=recursive-random,caption=Retrieve random values through a recursive function and store them in an array]
...
private static Random random;
private static long[] timestamps;

private static float[] initializeRandomArray (int size) {
	return addRandom(new float[size], new long[size], 0, size);
}
	
/**
* Recursive function to construct a float[] with length of count filled with java.util.Random output values.
* @param array Enriched with a new random.nextFloat() each iteration.
* @param timestamps Saves System.currentTimeMillis() each recursive call.
* @param count The amount of values the result will eventually have.
* @return float[] filled with count number of java.util.Random output values.
*/
private static float[] addRandom(float[] array, long[] timestamps, int index, int count) {
	if (index >= count) {
		// Set static variable 'timestamps'
		Experiment.timestamps = timestamps;
		return array;
	} else {
		timestamps[index] = System.currentTimeMillis();
		array[index] = random.nextFloat();
	}
	return addRandom(array, timestamps, ++index, count);
}
...
\end{lstlisting}
In the code above~\ref{recursive-random} the researcher chose to use a primitive array of type float to store outputs into. He chose that because he uses Renjin for this research, and one can easily pass primitives to the Renjin R interpreter.
\\
\\
WE/THE RESEARCHER AND DEFINE 'DAMAGE'
In the code of listing~\ref{recursive-random} we can also see that outputs are collected through a recursive function. The researcher believes that timestamps can be a contributing factor in the mechanism of \texttt{java.util.Random.nextFloat()}. Therefore, in an effort to minimize the damage different timestamps could have on ouputs, we first store all function calls on the stack. When we exit the recursive function all calls are then fired all at once. In addition the timestamps (in milliseconds) are also collected and stored in \texttt{long[] timestamps}.
\\
\\
CORRELATION OR PATTERN?? => PATTERN
The experiment is conducted by retrieving \texttt{java.util.Random.nextFloat()} output values in as little time possible. This is done four times with array lengths: \texttt{10, 100, 1000} and \texttt{7000}. We then calculate the arithmetic mean, median, mode and standard deviation. These values can then be used to compare mean with median and to calculate probability with R's \texttt{pnorm} function. The results of these comparisons and probabilities can then be analyzed. If we can find one or more correlations in the output values this means that \texttt{java.util.Random.nextFloat()} is not random at all but instead follows those correlations.

%----------------------------------------------------------------------------------------
%	RESULTS
%----------------------------------------------------------------------------------------

\section{Results}

MAAK ER EEN TABEL VAN
The following (listing~\ref{results}) is the output of the program.
\\
\begin{lstlisting}[language={},label=results,caption=Ouput of the program]
Experiment [n=10]: 
Generating java.util.Random values took 1.0 millisecond(s)

Mean                 [1] 0.39593282938004
Median               [1] 0.32979026436806
Mode                 [1] 0.14058691263199
Standard deviation                 [,1]
[1,] 0.26815442694344
-------------------------------------------
Mean +- median       [1] 0.06614256501198

Probability n > 0                       [,1]
[1,] 0.93009655189399
Probability n < 1                       [,1]
[1,] 0.98786045781739
Probability n > median                  [,1]
[1,] 0.59741373140378
Probability n < median                  [,1]
[1,] 0.40258626859622
Probability n > mode                    [,1]
[1,] 0.82951098505196
Probability n < mode                    [,1]
[1,] 0.17048901494804



Experiment [n=100]: 
Generating java.util.Random values took 1.0 millisecond(s)

Mean                 [1] 0.49393919229507
Median               [1] 0.46484676003456
Mode                 [1] 0.10284048318863
Standard deviation                [,1]
[1,] 0.2714489869447
-------------------------------------------
Mean +- median       [1] 0.02909243226051

Probability n > 0                       [,1]
[1,] 0.96559300898027
Probability n < 1                       [,1]
[1,] 0.96885980880285
Probability n > median                  [,1]
[1,] 0.54267476085866
Probability n < median                  [,1]
[1,] 0.45732523914134
Probability n > mode                    [,1]
[1,] 0.92517680512418
Probability n < mode                    [,1]
[1,] 0.07482319487582



Experiment [n=1000]: 
Generating java.util.Random values took 2.0 millisecond(s)

Mean                 [1] 0.49332589697838
Median               [1] 0.4915097951889
Mode                 [1] 0.93314707279205
Standard deviation                 [,1]
[1,] 0.29082325410522
-------------------------------------------
Mean +- median       [1] 0.00181610178947

Probability n > 0                       [,1]
[1,] 0.95508624436552
Probability n < 1                       [,1]
[1,] 0.95926382325647
Probability n > median                  [,1]
[1,] 0.50249125566892
Probability n < median                  [,1]
[1,] 0.49750874433108
Probability n > mode                    [,1]
[1,] 0.06522477234239
Probability n < mode                    [,1]
[1,] 0.93477522765761



Experiment [n=7000]: 
new double array length = 7000
new double array length = 7000
Generating java.util.Random values took 1.0 millisecond(s)
new double array length = 7000
building DoubleVector = 7000
IntArrayVector alloc = 7000

Mean                 [1] 0.50724935386862
Median               [1] 0.50939035415649
Mode                 [1] 0.31117027997971
Standard deviation                [,1]
[1,] 0.2861182375764
-------------------------------------------
Mean +- median       [1] -0.00214100028787

Probability n > 0                       [,1]
[1,] 0.96187456005885
Probability n < 1                       [,1]
[1,] 0.95748266186443
Probability n > median                  [,1]
[1,] 0.49701477412488
Probability n < median                  [,1]
[1,] 0.50298522587512
Probability n > mode                    [,1]
[1,] 0.75342515998576
Probability n < mode                    [,1]
[1,] 0.24657484001424
\end{lstlisting}

\begin{table}[]
\centering
\caption{Results of Computations}
\label{my-label}
\begin{tabular}{lllll}
 &  &  &  &  \\
 &  &  &  &  \\
 &  &  &  &  \\
 &  &  &  & 
\end{tabular}
\end{table}

We want to find one or more correlation in the output above, thus proving that \texttt{java.util.Random.nextFloat()} follows a pattern. If we can prove that a pattern is being followed, our hypotheses is wrong.
\\
\\
In all executions of the program (\texttt{n=10, n=100, n=1000} and \texttt{n=7000}) the mean lies very close to the median. This indicates that the differences between each \texttt{n} and \texttt{n+1} are more or less the same for the whole range (0-1). In other words, it indicates that we have little to no outliers in our results.
\\
\\
If we compare the probabilities of each experiment (\texttt{n=10, n=100, n=1000} and \texttt{n=7000}), we also see that results are generally very close to each other. The probability of an entry \texttt{n > 0} means: what is the chance that this entry is bigger than \texttt{0}? And so we can see that all our data sets are evenly distributed, because \texttt{$n <> median \approx 0.5$} and our modes are never close to \texttt{0.5}.

%----------------------------------------------------------------------------------------
%	DISCUSSION
%----------------------------------------------------------------------------------------

\section{Discussion}

The researcher states some facts about JVM runtime environment, but this research never clears if those facts indeed change the measurement results.
\\
\\
Stack memory is limited and is therefore a bottleneck in how many recursive function calls can be stored on it. In the case of this study only 7000 output values with their corresponding timestamps could be retrieved without triggering a \texttt{stack overflow exception}. We do not know how many output values are actually needed for a trustworthy result. More is better is the norm here.
\\
\\
The researcher believes timestamps can have an impact on the outputs of\\ \texttt{java.util.Random.nextFloat()}, while never proving it. This could be inspected by looking at the actual source code of \texttt{java.util.Random} and determining if the source code is in any way associated with time and/or timestamps.

%----------------------------------------------------------------------------------------
%	CONCLUSION
%----------------------------------------------------------------------------------------

\section{Conclusion}

GIVEN THE THINGS MENTIONED IN DISCUSSION, WE CAN ASSUME THAT...
Q.E.D. Because we see a clear correlation between our data sets in that they are all evenly distributed we can conclude that this is a pattern that outputs of \\\texttt{java.util.Random.nextFloat()} follow, thus proving that \texttt{java.util.Random.nextFloat()} \textbf{does} follow a clear pattern.

\end{document}